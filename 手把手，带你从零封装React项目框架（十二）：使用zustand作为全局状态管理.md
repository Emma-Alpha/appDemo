### 前言

在现代的前端框架中，状态管理是大家永远逃不开的一个问题。不管是 react 还是 vue，都是组件化开发，这样虽然可以提高代码的复用性，但是同时也产生了一个问题，就是组件之间的通信问题。父子组件的通信比较容易，但是如果组件之间没有关系又该如何进行状态的我共享和使用呢？这时我们就要将这些公共的数据进行提取，放在一个独立的状态仓库中进行管理，而这就是状态管理

### 状态和状态管理

#### 状态

React、Vue 等前端框架关注那些已经被声明成需要监视的变量，当这些变量发生变化时，就会触发组件的重新渲染，而这些变量就是状态。状态是数据的变化，比如颜色是红色或者绿色，这是数据，但是颜色从红色变为绿色，这就是状态。

#### 状态管理

而状态管理，就是维护应用的数据变化。状态管理具体有两个方面，一是状态变化之前的逻辑处理，一般为异步处理。比如 react 的 setState 就是异步进行处理的。二是状态变化之后，如何进行视图的重新渲染或者执行某段逻辑。比如请求的数据返回后，如何展示给用户。

![image-20230830102448095](https://typora.gz4399.com/typora/20238/20230830_1693362288168330000.png)

### 状态管理工具的比较

目前流行的状态管理工具有很多，react 推荐的 redux，dva，mobx 以及 zustand 等等，他们都有很多的使用者，接下来将会简单的说明他们各自的优势和缺点，并说明最后为什么选择 zustand。

#### redux

redux 是一个专门用来做状态管理的 js 库，基本与 react 配合使用，作用是集中式管理 react 应用中的多个组件共享状态
他的工作流程大致如下，

- 用户触发事件，事件通过 dispatch 发送 action 和 payload
- action 和 payload 被传入 store 中的 reducer 函数，返回新的 state
- store 拿到最新的 state 并更新，同时通知 view 层重新渲染

![image-20230830102526338](https://typora.gz4399.com/typora/20238/20230830_1693362326411147000.png)

##### 优点

- 可预测性：Redux 使用单一的状态树（state tree）来存储整个应用程序的状态，使得状态变化可预测且易于调试。通过在应用程序中实现纯函数的方式来修改状态，可以确保状态变化的可追溯性
- 可扩展性：Redux 采用了中间件（middleware）机制，允许开发人员在状态变化的过程中添加自定义逻辑。这使得应用程序的功能可以轻松地扩展和定制，例如添加日志记录、异步操作处理等
- 组件解耦：Redux 将状态从组件中分离出来，使得组件只需关注渲染和用户交互，而不需要关心状态的获取和更新。这种解耦有助于提高组件的可复用性和可测试性

##### 缺点

- 冗余代码：Redux 的使用可能会导致一些冗余的代码，例如定义 action 和 reducer 等。虽然这些代码可以提高应用程序的可维护性和可测试性，但也增加了开发工作量
- 过度使用：有时候开发人员可能会过度使用 Redux，将所有的状态都存储在 Redux 中，即使某些状态只在组件内部使用。这样做可能会导致不必要的复杂性和性能问题

#### mobx

mobx 是一个响应式的状态管理工具，工作流程大致如下

- 用户触发事件，事件触发 action 执行，通过 action 修改 state
- state 更新后，computed Values 会根据依赖重新计算属性值
- 状态更新后会触发 reactions，来响应这次状态变化的一些操作

![image-20230830102557124](https://typora.gz4399.com/typora/20238/20230830_1693362357184604000.png)

​																					

##### 优点

- 简单易用：相对于 Redux 而言，MobX 的学习曲线较为平缓。它使用装饰器和观察者模式等概念，使得状态管理变得更加直观和简单
- 响应式更新：MobX 使用响应式编程的思想，当状态发生变化时，相关的组件会自动进行更新。
- 更少的样板代码：相比于 Redux，MobX 通常需要更少的样板代码。在 MobX 中，只需定义可观察的状态和相关的动作，而无需编写繁琐的 reducer 和 action 等
- 性能优化：MobX 通过使用细粒度的观察机制，可以实现局部更新，从而提高应用程序的性能。只有与状态相关的组件才会进行更新，而不是整个应用程序

##### 缺点

- 难以追踪状态变化：相对于 Redux 的单一状态树，MobX 的状态分散在多个可观察对象中。这可能导致状态变化的追踪和调试变得更加困难
- 隐式依赖：在 MobX 中，状态的更新是自动进行的，这可能导致一些隐式的依赖关系。当状态变化时，相关的组件会自动更新，但开发人员可能不太容易追踪和控制这些依赖关系
- 对 ES6 装饰器的依赖：MobX 使用 ES6 装饰器来定义可观察的状态和动作，这要求项目环境支持装饰器语法。对于一些老旧的项目或特定的开发环境，可能需要额外的配置和兼容性处理

#### zustand

zustand 是德语，状态的意思。

##### 安装

使用 pnpm 安装

```shell
pnpm install zustand
```

##### 数据流程

zustand 的数据流程大致如下：
首先使用 create 创建 store

```tsx
import { create } from "zustand";

interface CountState {
  count: number,

  getCount: (params: any) => Promise<void>,
}

const useCountStore = create<CountState>()((set, get) => ({
  count: 0,

  getCount: async (params: any) => {
    const { data } = await apiGetCount(params)
    set({ count: data?. })
  }
}))

export default useCountStore
```

然后在页面中使用

```ts
import React, { useEffect } from 'react';
import useCountStore from '../../../store/test';

const CountShow = () => {
  const { count, getCount } = useCountStore();

  useEffect(() => {
    // 初始化获取count
    getCount();
  });

  return <div>
  { count }
   <button onClick={getCount}>同步</button>
  <div>;
};
```

##### 优点

- 简单易用：Zustand 相对于其他状态管理库而言，具有更低的学习曲线。它使用了 React 的 Hooks API，使得状态管理变得更加直观和容易上手
- 响应式更新：Zustand 使用了响应式编程的思想，当状态发生变化时，相关的组件会自动进行更新。这种自动更新机制减少了手动操作的需求，提高了开发效率
- 更少的样板代码：与其他状态管理库相比，Zustand 通常需要更少的样板代码。在 Zustand 中，只需定义状态和相关的动作，而无需编写繁琐的 reducer 和 action 等
- 性能优化：Zustand 通过使用浅层比较和 Immer 库等技术，可以实现局部更新，从而提高应用程序的性能。只有与状态相关的组件才会进行更新，而不是整个应用程序

##### 缺点

- 较小的生态系统：相对于一些更成熟的状态管理库，Zustand 的生态系统相对较小。这意味着可能会找到较少的第三方插件和工具，以及较少的社区支持

### 总结

通过对比 redux、mobx 以及 zustand，可以看出 zustand 的使用上会比较的简单便捷，而且代码上会更加的简洁，并且符合 react 的 hooks 使用。因此非常符合目前项目的状态管理库的需求。